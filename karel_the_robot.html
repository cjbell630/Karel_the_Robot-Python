<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>karel_the_robot API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>karel_the_robot</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy
import threading
import time
from functools import wraps
from itertools import count
import traceback
import os

os.environ[&#39;PYGAME_HIDE_SUPPORT_PROMPT&#39;] = &#34;hide&#34;
import pygame

SCREEN_WIDTH = 600
SCREEN_HEIGHT = 600
TILE_WIDTH = 10
# TODO: maybe make has moved this frame a global
FPS = 4

BEEPERS = pygame.sprite.Group()
WALLS = []

# COLORS
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
L_GREY = (158, 158, 158)
D_GREY = (56, 56, 56)
GREEN = (91, 153, 0)
RED = (240, 0, 0)
L_BLUE = (0, 124, 150)
D_BLUE = (34, 25, 117)
YELLOW = (255, 236, 0)
CLR = (1, 1, 1)
ORANGE = (255, 165, 0)
PINK = (255, 165, 245)
TEAL = (0, 160, 180)
PURPLE = (200, 0, 255)

SLEEVE_COLORS = [
    (&#34;Green&#34;, GREEN), (&#34;Orange&#34;, ORANGE), (&#34;Pink&#34;, PINK), (&#34;Blue&#34;, TEAL), (&#34;Purple&#34;, PURPLE)
]
&#34;&#34;&#34;SLEEVE_COLORS documentation&#34;&#34;&#34;

KAREL_ON = numpy.array([
    [CLR, CLR, CLR, CLR, CLR, CLR, BLACK, BLACK, BLACK, BLACK, CLR, CLR, CLR, BLACK, BLACK, BLACK, BLACK, CLR, CLR, CLR,
     CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, BLACK, RED, RED, RED, BLACK, CLR, CLR, CLR, BLACK, RED, RED, RED, BLACK, CLR, CLR, CLR,
     CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, BLACK, RED, RED, RED, RED, BLACK, D_BLUE, BLACK, RED, RED, RED, RED, BLACK, CLR, CLR, CLR,
     CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK,
     CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, BLACK, BLACK, BLACK, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW,
     YELLOW, BLACK, BLACK, BLACK, CLR, CLR, CLR],
    [CLR, CLR, CLR, BLACK, D_GREY, BLACK, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW,
     YELLOW, YELLOW, BLACK, D_GREY, BLACK, CLR, CLR, CLR],
    [CLR, CLR, CLR, BLACK, D_GREY, BLACK, YELLOW, YELLOW, YELLOW, BLACK, YELLOW, YELLOW, YELLOW, BLACK, YELLOW, YELLOW,
     YELLOW, BLACK, D_GREY, BLACK, CLR, CLR, CLR],
    [CLR, CLR, CLR, BLACK, GREEN, BLACK, YELLOW, YELLOW, YELLOW, BLACK, YELLOW, YELLOW, BLACK, YELLOW, YELLOW, YELLOW,
     YELLOW, BLACK, GREEN, BLACK, CLR, CLR, CLR],
    [CLR, CLR, CLR, BLACK, GREEN, BLACK, YELLOW, YELLOW, YELLOW, BLACK, YELLOW, BLACK, YELLOW, YELLOW, YELLOW, YELLOW,
     YELLOW, BLACK, GREEN, BLACK, CLR, CLR, CLR],
    [CLR, CLR, CLR, BLACK, GREEN, BLACK, YELLOW, YELLOW, YELLOW, BLACK, BLACK, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW,
     YELLOW, BLACK, GREEN, BLACK, CLR, CLR, CLR],
    [CLR, CLR, CLR, BLACK, GREEN, BLACK, YELLOW, YELLOW, YELLOW, BLACK, YELLOW, BLACK, YELLOW, YELLOW, YELLOW, YELLOW,
     YELLOW, BLACK, GREEN, BLACK, CLR, CLR, CLR],
    [CLR, CLR, CLR, BLACK, GREEN, BLACK, YELLOW, YELLOW, YELLOW, BLACK, YELLOW, YELLOW, BLACK, YELLOW, YELLOW, YELLOW,
     YELLOW, BLACK, GREEN, BLACK, CLR, CLR, CLR],
    [CLR, CLR, CLR, BLACK, GREEN, BLACK, YELLOW, YELLOW, YELLOW, BLACK, YELLOW, YELLOW, YELLOW, BLACK, YELLOW, YELLOW,
     YELLOW, BLACK, GREEN, BLACK, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, BLACK, BLACK, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW,
     YELLOW, BLACK, BLACK, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, BLACK, BLACK, YELLOW, YELLOW, YELLOW, BLACK, BLACK, BLACK, YELLOW, YELLOW, YELLOW, BLACK,
     BLACK, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, CLR, BLACK, BLACK, BLACK, BLACK, L_GREY, L_GREY, L_GREY, BLACK, BLACK, BLACK, BLACK, CLR,
     CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, BLACK, L_GREY, L_GREY, L_GREY, L_GREY,
     L_GREY, BLACK, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, BLACK, L_GREY, L_GREY, D_GREY, D_GREY, L_GREY, L_GREY, L_GREY, D_GREY, D_GREY, L_GREY,
     L_GREY, BLACK, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, BLACK, L_GREY, D_GREY, BLACK, BLACK, D_GREY, L_GREY, D_GREY, BLACK, BLACK, D_GREY, L_GREY,
     BLACK, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, BLACK, L_GREY, D_GREY, L_BLUE, BLACK, D_GREY, L_GREY, D_GREY, L_BLUE, BLACK, D_GREY,
     L_GREY, BLACK, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, BLACK, L_GREY, L_GREY, D_GREY, D_GREY, L_GREY, L_GREY, L_GREY, D_GREY, D_GREY, L_GREY,
     L_GREY, BLACK, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, CLR, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, BLACK,
     CLR, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, CLR, CLR, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, CLR, CLR, CLR,
     CLR, CLR, CLR, CLR]
])

BEEPER = [
    [CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, CLR, CLR, CLR, CLR, CLR,
     CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, CLR, BLACK, BLACK, D_GREY, D_GREY, D_GREY, D_GREY, D_GREY, D_GREY, D_GREY, BLACK, BLACK,
     CLR, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, BLACK, D_GREY, D_GREY, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, D_GREY, D_GREY,
     BLACK, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, BLACK, D_GREY, BLACK, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, BLACK,
     BLACK, D_GREY, BLACK, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, BLACK, D_GREY, D_GREY, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY,
     L_GREY, BLACK, D_GREY, D_GREY, BLACK, CLR, CLR, CLR],
    [CLR, CLR, BLACK, D_GREY, BLACK, BLACK, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY,
     L_GREY, BLACK, BLACK, BLACK, D_GREY, BLACK, CLR, CLR],
    [CLR, CLR, BLACK, D_GREY, BLACK, L_GREY, L_GREY, BLACK, L_GREY, L_GREY, BLACK, BLACK, BLACK, L_GREY, L_GREY, BLACK,
     L_GREY, L_GREY, BLACK, D_GREY, BLACK, CLR, CLR],
    [CLR, BLACK, D_GREY, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, BLACK, RED, RED, RED, BLACK, L_GREY, L_GREY,
     L_GREY, L_GREY, L_GREY, BLACK, D_GREY, BLACK, CLR],
    [CLR, BLACK, D_GREY, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, BLACK, RED, RED, RED, RED, RED, BLACK, L_GREY, L_GREY,
     L_GREY, L_GREY, BLACK, D_GREY, BLACK, CLR],
    [CLR, BLACK, D_GREY, BLACK, L_GREY, L_GREY, L_GREY, BLACK, RED, RED, RED, RED, RED, RED, RED, BLACK, L_GREY, L_GREY,
     L_GREY, BLACK, D_GREY, BLACK, CLR],
    [CLR, BLACK, D_GREY, BLACK, L_GREY, L_GREY, L_GREY, BLACK, RED, RED, RED, RED, RED, RED, RED, BLACK, L_GREY, L_GREY,
     L_GREY, BLACK, D_GREY, BLACK, CLR],
    [CLR, BLACK, D_GREY, BLACK, L_GREY, L_GREY, L_GREY, BLACK, RED, RED, RED, RED, RED, RED, RED, BLACK, L_GREY, L_GREY,
     L_GREY, BLACK, D_GREY, BLACK, CLR],
    [CLR, BLACK, D_GREY, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, BLACK, RED, RED, RED, RED, RED, BLACK, L_GREY, L_GREY,
     L_GREY, L_GREY, BLACK, D_GREY, BLACK, CLR],
    [CLR, BLACK, D_GREY, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, BLACK, RED, RED, RED, BLACK, L_GREY, L_GREY,
     L_GREY, L_GREY, L_GREY, BLACK, D_GREY, BLACK, CLR],
    [CLR, CLR, BLACK, D_GREY, BLACK, L_GREY, L_GREY, BLACK, L_GREY, L_GREY, BLACK, BLACK, BLACK, L_GREY, L_GREY, BLACK,
     L_GREY, L_GREY, BLACK, D_GREY, BLACK, CLR, CLR],
    [CLR, CLR, BLACK, D_GREY, BLACK, BLACK, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY,
     L_GREY, BLACK, BLACK, BLACK, D_GREY, BLACK, CLR, CLR],
    [CLR, CLR, CLR, BLACK, D_GREY, D_GREY, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY,
     L_GREY, BLACK, D_GREY, D_GREY, BLACK, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, BLACK, D_GREY, BLACK, BLACK, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, L_GREY, BLACK,
     BLACK, D_GREY, BLACK, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, BLACK, D_GREY, D_GREY, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, D_GREY, D_GREY,
     BLACK, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, CLR, BLACK, BLACK, D_GREY, D_GREY, D_GREY, D_GREY, D_GREY, D_GREY, D_GREY, BLACK, BLACK,
     CLR, CLR, CLR, CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, BLACK, CLR, CLR, CLR, CLR, CLR,
     CLR, CLR, CLR],
    [CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR, CLR],
]

BEEPER_SURF = 0


def continued_exception(text):
    try:
        raise Exception(text)
    except Exception as exc:
        print(&#34;\n&#34;)
        traceback.print_stack(limit=-1)
        traceback.print_exception(Exception, exc, None, limit=-1)


def replace_2d(array, value, replacement):
    array = array.copy()
    for x in range(0, len(array)):
        for y in range(0, len(array[x])):
            if all(array[x][y] == value):
                array[x][y] = replacement
    return array


def readable_pixarray_to_surface(array):
    # array = array.swapaxes(0, 1)
    surf = pygame.Surface(array.shape[0:2], pygame.SRCALPHA).convert()
    pygame.surfarray.blit_array(surf, array)
    surf.set_colorkey(CLR)
    return surf


def tile_to_point(tile):
    global TILE_WIDTH
    return (tile + 0.5) * TILE_WIDTH


def point_to_tile(point):
    global TILE_WIDTH
    return (point / TILE_WIDTH) - 0.5


def wall_at(tile_x, tile_y):
    global WALLS
    for w in WALLS:
        if w[0] == tile_x and w[1] == tile_y:
            return True
    return False


def extract_vals_inside_parenthesis(string, open_parenthesis_index):
    p = []
    temp = &#34;&#34;
    count = open_parenthesis_index + 1
    while count &lt; len(string):
        if string[count] == &#39; &#39;:
            p.append(temp)
            temp = &#34;&#34;
        elif string[count] == &#39;)&#39;:
            p.append(temp)
            return p
        else:
            temp += string[count]
        count += 1
    return p


&#34;&#34;&#34;text above class declaration&#34;&#34;&#34;


class Robot(pygame.sprite.Sprite):
    &#34;&#34;&#34;documentation for Robot
    

    &#34;&#34;&#34;
    __ids = count(0)

    def __init__(self, x, y, direction, num_of_beepers, color=-1):  # color is an int, maybe add string colors eventually
        super().__init__()
        self.id = next(self.__ids)
        &#34;&#34;&#34;documentation for self.id&#34;&#34;&#34;
        self.__color = SLEEVE_COLORS[(self.id if color == -1 else color) % len(SLEEVE_COLORS)]
        self.__tile_x = x
        self.__tile_y = y
        self.__direction = direction
        self.__beepers = num_of_beepers
        self.has_moved_this_frame = True
        self.__image = 0
        self.__rect = 0
        self.is_alive = True
        self.__prev_fps = 4
        self.__zoom_fps = 20
        # self.array = numpy.where(KAREL_ON == , self.__color, KAREL_ON)
        self.__array = replace_2d(KAREL_ON, GREEN, self.__color[1])

        print(&#34;[&#34; + self.__color[0] + &#34; Robot] Initializing...&#34;)

    def scale_image(self, width):
        &#34;&#34;&#34;documentation for scale_image&#34;&#34;&#34;
        self.__image = pygame.transform.rotate(
            pygame.transform.scale(readable_pixarray_to_surface(self.__array), (width, width)),
            self.__direction)
        self.__rect = self.__image.get_rect()
        self.__rect.x = tile_to_point(self.__tile_x - 0.5)
        self.__rect.y = tile_to_point(self.__tile_y - 0.5)

    def get_sleeve_color(self):
        return self.__color[0]

    def turn_left(self):
        if self.is_alive:
            self.wait()
            self.__image = pygame.transform.rotate(self.__image, 90)
            self.__direction = (self.__direction + 90) % 360
            self.has_moved_this_frame = True

    def move(self):

        if self.is_alive:
            self.wait()
            if self.front_is_clear():
                if self.__direction == 0:
                    self.__rect.x += TILE_WIDTH
                    self.__tile_x += 1
                elif self.__direction == 180:
                    self.__rect.x -= TILE_WIDTH
                    self.__tile_x -= 1
                elif self.__direction == 270:
                    self.__rect.y += TILE_WIDTH
                    self.__tile_y += 1
                elif self.__direction == 90:
                    self.__rect.y -= TILE_WIDTH
                    self.__tile_y -= 1
            else:
                continued_exception(&#34;[&#34; + self.__color[0] + &#34; Robot] I ran into a wall! &#34;)
                self.turn_off()

            print(&#34;tried to move&#34;)
            self.has_moved_this_frame = True

    def pick_beeper(self):
        global BEEPERS

        if self.is_alive:
            self.wait()
            beepers_at_pos = [b for b in BEEPERS if b.__tile_x == self.__tile_x and b.__tile_y == self.__tile_y]
            if len(beepers_at_pos) &gt; 0:
                beepers_at_pos[0].dec()
                self.__beepers += 1
            self.has_moved_this_frame = True

    def put_beeper(self):
        global BEEPERS

        if self.is_alive:
            self.wait()
            if self.has_any_beepers():
                beepers_at_pos = [b for b in BEEPERS if b.tile_x == self.__tile_x and b.tile_y == self.__tile_y]
                self.__beepers -= 1
                if len(beepers_at_pos) &gt; 0:
                    beepers_at_pos[0].inc()
                else:
                    BEEPERS.add(Beeper(self.__tile_x, self.__tile_y, 1))
            else:
                # raise Exception(&#34;[&#34; + self.__color[0] + &#34; Robot] I don&#39;t have any beepers! &#34;)
                continued_exception(&#34;[&#34; + self.__color[0] + &#34; Robot] I don&#39;t have any beepers! &#34;)
                self.turn_off()

            print(&#34;tried to put beeper&#34; + str(self.__beepers))
            self.has_moved_this_frame = True

    def wait(self):
        global FPS
        if self.is_alive:  # prevents commands from being run before the loop checks for dead robots, putting it in an infinite loop
            while self.has_moved_this_frame:
                # print(&#34;waiting for frame&#34;)
                time.sleep(1.0 / FPS)

    def has_any_beepers(self):
        return self.__beepers &gt; 0

    def front_is_clear(self):
        if self.__direction == 0:
            return not wall_at(self.__tile_x + 0.5, self.__tile_y)
        elif self.__direction == 180:
            return not wall_at(self.__tile_x - 0.5, self.__tile_y)
        elif self.__direction == 270:
            return not wall_at(self.__tile_x, self.__tile_y + 0.5)
        elif self.__direction == 90:
            return not wall_at(self.__tile_x, self.__tile_y - 0.5)
        else:
            return False

    def turn_off(self):
        global TILE_WIDTH

        if self.is_alive:
            self.wait()
            self.is_alive = False
            self.__array = replace_2d(self.__array, YELLOW, L_GREY)
            self.scale_image(TILE_WIDTH)
            print(&#34;am dead&#34;)

    def draw(self, screen):
        screen.blit(self.__image, (self.__rect.x, self.__rect.y))

    # https://medium.com/@mgarod/dynamically-add-a-method-to-a-class-in-python-c49204b85bd6
    def add_method(self):
        def decorator(func):
            @wraps(func)
            def wrapper(self, *args, **kwargs):
                return func(self, *args, **kwargs)

            setattr(self, func.__name__, wrapper)
            # Note we are not binding func, but wrapper which accepts self but does exactly the same as func
            return func  # returning func means func can still be used normally

        return decorator

    def set_zoom_fps(self, fps):
        self.__zoom_fps = fps

    def zoom(self, on):  # TODO: zooming is quirky

        if self.is_alive:
            self.wait()
            global FPS
            self.has_moved_this_frame = True
            if on:
                self.__prev_fps = FPS
                FPS = self.__zoom_fps
                print(&#34;ZOOM&#34;)
            else:
                FPS = self.__prev_fps
                print(&#34;no longer zooming&#34;)


class Beeper(pygame.sprite.Sprite):
    def __init__(self, x, y, num):
        super().__init__()
        global BEEPER_SURF
        self.tile_x = x
        self.tile_y = y
        self.num = num
        self.image = 0
        self.rect = 0
        self.update_image()

    def inc(self):
        self.num += 1
        self.update_image()

    def dec(self):
        global BEEPERS
        self.num -= 1
        if self.num &lt; 1:
            BEEPERS.remove(self)
            self.kill()
        else:
            self.update_image()

    def update_image(self):
        global BEEPER_SURF
        self.image = BEEPER_SURF.copy()
        self.image.blit(
            pygame.font.Font(&#39;freesansbold.ttf&#39;, 10 if len(str(self.num)) == 1 else 8).render(str(self.num), True,
                                                                                              BLACK),
            ((0.475 if len(str(self.num)) == 1 else 0.45) * TILE_WIDTH, 0.425 * TILE_WIDTH))
        self.rect = self.image.get_rect()
        self.rect.x = tile_to_point(self.tile_x - 0.5)
        self.rect.y = tile_to_point(self.tile_y - 0.5)

    def draw(self, screen):
        screen.blit(self.image, (self.rect.x, self.rect.y))


class World(object):
    # maybe add window size attributes
    def __init__(self, width, height, name=&#34;Karel J Robot&#34;, fps=4, beeper_pos=[], wall_pos=[]):
        global FPS, BEEPERS
        self.IDEAL_HEIGHT = 700
        self.IDEAL_WIDTH = 900
        FPS = fps

        self.__width = width
        self.__height = height
        self.__beeper_pos = beeper_pos
        self.__wall_pos = wall_pos

        BEEPERS = pygame.sprite.Group()
        self.__robots = []
        self.__screen = None
        self.__background = None
        self.__running = False
        self.__clock = None
        self.__idle_frames = 0
        # self.interval = 10

        self.__thread = threading.Thread(target=self.__run, args=())
        self.__thread.daemon = False  # Daemonize thread
        self.__name = name

    @classmethod  # constructor for loading a file
    def from_file(cls, filename):
        file = open(filename)
        width = 0
        height = 0
        fps = 4
        name = &#34;Karel J Robot&#34;
        beepers = []
        walls = []

        for l in file:
            if l.startswith(&#34;legacy: &#34;):
                print(&#34;legacy mode&#34;)
            elif l.startswith(&#34;name: &#34;) and len(l) &gt; 6:
                name = str(l[6:])
            elif l.startswith(&#34;size: &#34;):
                for i in range(6, len(l)):
                    if l[i] == &#39;(&#39;:
                        p = extract_vals_inside_parenthesis(l, i)
                        if len(p) == 2:
                            width = int(p[0])
                            height = int(p[1])
            elif l.startswith(&#34;fps: &#34;) and len(l) &gt; 5:
                fps = int(l[5:])
            elif l.startswith(&#34;beepers: &#34;):
                for i in range(9, len(l)):
                    if l[i] == &#39;(&#39;:
                        p = extract_vals_inside_parenthesis(l, i)
                        if len(p) == 3:
                            beepers.append((int(p[0]), int(p[1]), int(p[2])))
            elif l.startswith(&#34;walls: &#34;):
                for i in range(7, len(l)):
                    if l[i] == &#39;(&#39;:
                        p = extract_vals_inside_parenthesis(l, i)
                        if len(p) == 4:
                            walls.append((0 if p[0] == &#39;h&#39; else 1, float(p[1]), float(p[2]), float(p[3])))
        file.close()
        return cls(width, height, name=name, fps=fps, beeper_pos=beepers, wall_pos=walls)

    def add_robots(self, *robots):
        if self.__thread.is_alive():
            continued_exception(&#34;[World] Cannot add robots while the world is running!&#34;)
        else:
            for r in robots:
                self.__robots.append(r)
                print(&#34;[World] Added &#34; + r.get_sleeve_color() + &#34; Robot&#34;)

    def save_screenshot(self, filename=&#34;screenshot.jpg&#34;):
        if not filename.endswith(&#34;.jpg&#34;):
            filename += &#34;.jpg&#34;
        if self.__thread.is_alive():
            pygame.image.save(self.__screen, filename)
            print(&#34;[World] Saved screenshot as \&#34;&#34; + filename + &#34;\&#34;.&#34;)
        else:
            continued_exception(&#34;[World] Cannot take screenshot until the world is running!&#34;)

    def set_fps(self, fps):
        global FPS
        FPS = fps
        print(&#34;[World] Changed FPS&#34;)

    def start(self):
        self.__thread.start()

    def __run(self):

        print(&#34;\n&#34; + &#34;[World] Initializing...&#34; + &#34;\n&#34;)
        global SCREEN_WIDTH, SCREEN_HEIGHT, TILE_WIDTH, FPS, BEEPERS, BEEPER_SURF, WALLS
        pygame.init()
        TILE_WIDTH = int(min(self.IDEAL_WIDTH / (self.__width + 1), self.IDEAL_HEIGHT / (self.__height + 1)))
        if TILE_WIDTH % 2 == 1:
            TILE_WIDTH -= 1
        SCREEN_WIDTH = TILE_WIDTH * (self.__width + 1)
        SCREEN_HEIGHT = TILE_WIDTH * (self.__height + 1)
        print(&#34;[World] Screen height is &#34; + str(SCREEN_HEIGHT))
        self.__screen = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])  # add scaling

        BEEPER_SURF = pygame.transform.scale(readable_pixarray_to_surface(numpy.array(BEEPER)),
                                             (TILE_WIDTH, TILE_WIDTH))

        print(&#34;[World] Scaling robots...&#34;)
        for r in self.__robots:
            r.scale_image(TILE_WIDTH)

        for p in self.__beeper_pos:
            BEEPERS.add(Beeper(p[0], p[1], p[2]))

        print(&#34;[World] Generating background...&#34;)
        self.__background = pygame.Surface([SCREEN_WIDTH, SCREEN_HEIGHT])
        self.__background.fill(WHITE)
        for x in range(0, self.__width + 1):
            pygame.draw.line(self.__background, BLACK, ((x + 0.5) * TILE_WIDTH, 0.5 * TILE_WIDTH),
                             ((x + 0.5) * TILE_WIDTH, (self.__height + 0.5) * TILE_WIDTH))
            self.__background.blit(pygame.font.Font(&#39;freesansbold.ttf&#39;, 10).render(str(x), True, BLACK),
                                   ((x + 0.5) * TILE_WIDTH, 0.25 * TILE_WIDTH))
        for y in range(0, self.__height + 1):
            pygame.draw.line(self.__background, BLACK, (0.5 * TILE_WIDTH, (y + 0.5) * TILE_WIDTH),
                             ((self.__width + 0.5) * TILE_WIDTH, (y + 0.5) * TILE_WIDTH))
            self.__background.blit(pygame.font.Font(&#39;freesansbold.ttf&#39;, 10).render(str(y), True, BLACK),
                                   (0.25 * TILE_WIDTH, (y + 0.5) * TILE_WIDTH))

        for w in self.__wall_pos:
            pygame.draw.line(self.__background, RED,
                             (tile_to_point(w[1]), tile_to_point(w[2])),
                             (tile_to_point(w[3] if w[0] == 0 else w[1]), tile_to_point(w[3] if w[0] == 1 else w[2])),
                             3)
            for i in range(0, int(abs(w[3] - w[1 if w[0] == 0 else 2]))):
                # works no matter what order the walls are in
                WALLS.append(
                    (w[1] + ((i + 0.5 if w[1] &lt;= w[3] else 0 - i - 0.5) if w[0] == 0 else 0),
                     w[2] + ((i + 0.5 if w[2] &lt;= w[3] else 0 - i - 0.5) if w[0] == 1 else 0))
                )
        pygame.display.set_caption(self.__name)

        self.__clock = pygame.time.Clock()
        self.__running = True
        self.__idle_frames = 0

        print(&#34;[World] Done!&#34; + &#34;\n\n\n\n&#34;)
        print(WALLS)
        # quits if it idles for more than one second
        while sum(r.is_alive for r in self.__robots) &gt; 0 and self.__idle_frames &lt; FPS:
            pygame.event.get()  # required or else the window thinks it&#39;s not responding
            self.__screen.blit(self.__background, (0, 0))
            BEEPERS.draw(self.__screen)

            any_robots_moved = False
            for r in self.__robots:
                any_robots_moved = any_robots_moved or r.has_moved_this_frame
                r.draw(self.__screen)
                r.has_moved_this_frame = False

            if any_robots_moved:
                self.__idle_frames = 0
            else:
                self.__idle_frames += 1

            self.__clock.tick(FPS)
            pygame.display.flip()
        print(&#34;[World] Saving screenshot...&#34;)
        pygame.image.save(self.__screen, &#34;final_world_status.jpg&#34;)
        print(&#34;[World] Quitting...&#34;)
        pygame.quit()</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="karel_the_robot.SLEEVE_COLORS"><code class="name">var <span class="ident">SLEEVE_COLORS</span></code></dt>
<dd>
<div class="desc"><p>SLEEVE_COLORS documentation</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="karel_the_robot.continued_exception"><code class="name flex">
<span>def <span class="ident">continued_exception</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def continued_exception(text):
    try:
        raise Exception(text)
    except Exception as exc:
        print(&#34;\n&#34;)
        traceback.print_stack(limit=-1)
        traceback.print_exception(Exception, exc, None, limit=-1)</code></pre>
</details>
</dd>
<dt id="karel_the_robot.extract_vals_inside_parenthesis"><code class="name flex">
<span>def <span class="ident">extract_vals_inside_parenthesis</span></span>(<span>string, open_parenthesis_index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_vals_inside_parenthesis(string, open_parenthesis_index):
    p = []
    temp = &#34;&#34;
    count = open_parenthesis_index + 1
    while count &lt; len(string):
        if string[count] == &#39; &#39;:
            p.append(temp)
            temp = &#34;&#34;
        elif string[count] == &#39;)&#39;:
            p.append(temp)
            return p
        else:
            temp += string[count]
        count += 1
    return p</code></pre>
</details>
</dd>
<dt id="karel_the_robot.point_to_tile"><code class="name flex">
<span>def <span class="ident">point_to_tile</span></span>(<span>point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def point_to_tile(point):
    global TILE_WIDTH
    return (point / TILE_WIDTH) - 0.5</code></pre>
</details>
</dd>
<dt id="karel_the_robot.readable_pixarray_to_surface"><code class="name flex">
<span>def <span class="ident">readable_pixarray_to_surface</span></span>(<span>array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readable_pixarray_to_surface(array):
    # array = array.swapaxes(0, 1)
    surf = pygame.Surface(array.shape[0:2], pygame.SRCALPHA).convert()
    pygame.surfarray.blit_array(surf, array)
    surf.set_colorkey(CLR)
    return surf</code></pre>
</details>
</dd>
<dt id="karel_the_robot.replace_2d"><code class="name flex">
<span>def <span class="ident">replace_2d</span></span>(<span>array, value, replacement)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_2d(array, value, replacement):
    array = array.copy()
    for x in range(0, len(array)):
        for y in range(0, len(array[x])):
            if all(array[x][y] == value):
                array[x][y] = replacement
    return array</code></pre>
</details>
</dd>
<dt id="karel_the_robot.tile_to_point"><code class="name flex">
<span>def <span class="ident">tile_to_point</span></span>(<span>tile)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tile_to_point(tile):
    global TILE_WIDTH
    return (tile + 0.5) * TILE_WIDTH</code></pre>
</details>
</dd>
<dt id="karel_the_robot.wall_at"><code class="name flex">
<span>def <span class="ident">wall_at</span></span>(<span>tile_x, tile_y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wall_at(tile_x, tile_y):
    global WALLS
    for w in WALLS:
        if w[0] == tile_x and w[1] == tile_y:
            return True
    return False</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="karel_the_robot.Beeper"><code class="flex name class">
<span>class <span class="ident">Beeper</span></span>
<span>(</span><span>x, y, num)</span>
</code></dt>
<dd>
<div class="desc"><p>simple base class for visible game objects</p>
<p>pygame.sprite.Sprite(*groups): return Sprite</p>
<p>The base class for visible game objects. Derived classes will want to
override the Sprite.update() method and assign Sprite.image and Sprite.rect
attributes.
The initializer can accept any number of Group instances that
the Sprite will become a member of.</p>
<p>When subclassing the Sprite class, be sure to call the base initializer
before adding the Sprite to Groups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Beeper(pygame.sprite.Sprite):
    def __init__(self, x, y, num):
        super().__init__()
        global BEEPER_SURF
        self.tile_x = x
        self.tile_y = y
        self.num = num
        self.image = 0
        self.rect = 0
        self.update_image()

    def inc(self):
        self.num += 1
        self.update_image()

    def dec(self):
        global BEEPERS
        self.num -= 1
        if self.num &lt; 1:
            BEEPERS.remove(self)
            self.kill()
        else:
            self.update_image()

    def update_image(self):
        global BEEPER_SURF
        self.image = BEEPER_SURF.copy()
        self.image.blit(
            pygame.font.Font(&#39;freesansbold.ttf&#39;, 10 if len(str(self.num)) == 1 else 8).render(str(self.num), True,
                                                                                              BLACK),
            ((0.475 if len(str(self.num)) == 1 else 0.45) * TILE_WIDTH, 0.425 * TILE_WIDTH))
        self.rect = self.image.get_rect()
        self.rect.x = tile_to_point(self.tile_x - 0.5)
        self.rect.y = tile_to_point(self.tile_y - 0.5)

    def draw(self, screen):
        screen.blit(self.image, (self.rect.x, self.rect.y))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Sprite</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="karel_the_robot.Beeper.dec"><code class="name flex">
<span>def <span class="ident">dec</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dec(self):
    global BEEPERS
    self.num -= 1
    if self.num &lt; 1:
        BEEPERS.remove(self)
        self.kill()
    else:
        self.update_image()</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Beeper.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, screen)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, screen):
    screen.blit(self.image, (self.rect.x, self.rect.y))</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Beeper.inc"><code class="name flex">
<span>def <span class="ident">inc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inc(self):
    self.num += 1
    self.update_image()</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Beeper.update_image"><code class="name flex">
<span>def <span class="ident">update_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_image(self):
    global BEEPER_SURF
    self.image = BEEPER_SURF.copy()
    self.image.blit(
        pygame.font.Font(&#39;freesansbold.ttf&#39;, 10 if len(str(self.num)) == 1 else 8).render(str(self.num), True,
                                                                                          BLACK),
        ((0.475 if len(str(self.num)) == 1 else 0.45) * TILE_WIDTH, 0.425 * TILE_WIDTH))
    self.rect = self.image.get_rect()
    self.rect.x = tile_to_point(self.tile_x - 0.5)
    self.rect.y = tile_to_point(self.tile_y - 0.5)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="karel_the_robot.Robot"><code class="flex name class">
<span>class <span class="ident">Robot</span></span>
<span>(</span><span>x, y, direction, num_of_beepers, color=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>documentation for Robot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Robot(pygame.sprite.Sprite):
    &#34;&#34;&#34;documentation for Robot
    

    &#34;&#34;&#34;
    __ids = count(0)

    def __init__(self, x, y, direction, num_of_beepers, color=-1):  # color is an int, maybe add string colors eventually
        super().__init__()
        self.id = next(self.__ids)
        &#34;&#34;&#34;documentation for self.id&#34;&#34;&#34;
        self.__color = SLEEVE_COLORS[(self.id if color == -1 else color) % len(SLEEVE_COLORS)]
        self.__tile_x = x
        self.__tile_y = y
        self.__direction = direction
        self.__beepers = num_of_beepers
        self.has_moved_this_frame = True
        self.__image = 0
        self.__rect = 0
        self.is_alive = True
        self.__prev_fps = 4
        self.__zoom_fps = 20
        # self.array = numpy.where(KAREL_ON == , self.__color, KAREL_ON)
        self.__array = replace_2d(KAREL_ON, GREEN, self.__color[1])

        print(&#34;[&#34; + self.__color[0] + &#34; Robot] Initializing...&#34;)

    def scale_image(self, width):
        &#34;&#34;&#34;documentation for scale_image&#34;&#34;&#34;
        self.__image = pygame.transform.rotate(
            pygame.transform.scale(readable_pixarray_to_surface(self.__array), (width, width)),
            self.__direction)
        self.__rect = self.__image.get_rect()
        self.__rect.x = tile_to_point(self.__tile_x - 0.5)
        self.__rect.y = tile_to_point(self.__tile_y - 0.5)

    def get_sleeve_color(self):
        return self.__color[0]

    def turn_left(self):
        if self.is_alive:
            self.wait()
            self.__image = pygame.transform.rotate(self.__image, 90)
            self.__direction = (self.__direction + 90) % 360
            self.has_moved_this_frame = True

    def move(self):

        if self.is_alive:
            self.wait()
            if self.front_is_clear():
                if self.__direction == 0:
                    self.__rect.x += TILE_WIDTH
                    self.__tile_x += 1
                elif self.__direction == 180:
                    self.__rect.x -= TILE_WIDTH
                    self.__tile_x -= 1
                elif self.__direction == 270:
                    self.__rect.y += TILE_WIDTH
                    self.__tile_y += 1
                elif self.__direction == 90:
                    self.__rect.y -= TILE_WIDTH
                    self.__tile_y -= 1
            else:
                continued_exception(&#34;[&#34; + self.__color[0] + &#34; Robot] I ran into a wall! &#34;)
                self.turn_off()

            print(&#34;tried to move&#34;)
            self.has_moved_this_frame = True

    def pick_beeper(self):
        global BEEPERS

        if self.is_alive:
            self.wait()
            beepers_at_pos = [b for b in BEEPERS if b.__tile_x == self.__tile_x and b.__tile_y == self.__tile_y]
            if len(beepers_at_pos) &gt; 0:
                beepers_at_pos[0].dec()
                self.__beepers += 1
            self.has_moved_this_frame = True

    def put_beeper(self):
        global BEEPERS

        if self.is_alive:
            self.wait()
            if self.has_any_beepers():
                beepers_at_pos = [b for b in BEEPERS if b.tile_x == self.__tile_x and b.tile_y == self.__tile_y]
                self.__beepers -= 1
                if len(beepers_at_pos) &gt; 0:
                    beepers_at_pos[0].inc()
                else:
                    BEEPERS.add(Beeper(self.__tile_x, self.__tile_y, 1))
            else:
                # raise Exception(&#34;[&#34; + self.__color[0] + &#34; Robot] I don&#39;t have any beepers! &#34;)
                continued_exception(&#34;[&#34; + self.__color[0] + &#34; Robot] I don&#39;t have any beepers! &#34;)
                self.turn_off()

            print(&#34;tried to put beeper&#34; + str(self.__beepers))
            self.has_moved_this_frame = True

    def wait(self):
        global FPS
        if self.is_alive:  # prevents commands from being run before the loop checks for dead robots, putting it in an infinite loop
            while self.has_moved_this_frame:
                # print(&#34;waiting for frame&#34;)
                time.sleep(1.0 / FPS)

    def has_any_beepers(self):
        return self.__beepers &gt; 0

    def front_is_clear(self):
        if self.__direction == 0:
            return not wall_at(self.__tile_x + 0.5, self.__tile_y)
        elif self.__direction == 180:
            return not wall_at(self.__tile_x - 0.5, self.__tile_y)
        elif self.__direction == 270:
            return not wall_at(self.__tile_x, self.__tile_y + 0.5)
        elif self.__direction == 90:
            return not wall_at(self.__tile_x, self.__tile_y - 0.5)
        else:
            return False

    def turn_off(self):
        global TILE_WIDTH

        if self.is_alive:
            self.wait()
            self.is_alive = False
            self.__array = replace_2d(self.__array, YELLOW, L_GREY)
            self.scale_image(TILE_WIDTH)
            print(&#34;am dead&#34;)

    def draw(self, screen):
        screen.blit(self.__image, (self.__rect.x, self.__rect.y))

    # https://medium.com/@mgarod/dynamically-add-a-method-to-a-class-in-python-c49204b85bd6
    def add_method(self):
        def decorator(func):
            @wraps(func)
            def wrapper(self, *args, **kwargs):
                return func(self, *args, **kwargs)

            setattr(self, func.__name__, wrapper)
            # Note we are not binding func, but wrapper which accepts self but does exactly the same as func
            return func  # returning func means func can still be used normally

        return decorator

    def set_zoom_fps(self, fps):
        self.__zoom_fps = fps

    def zoom(self, on):  # TODO: zooming is quirky

        if self.is_alive:
            self.wait()
            global FPS
            self.has_moved_this_frame = True
            if on:
                self.__prev_fps = FPS
                FPS = self.__zoom_fps
                print(&#34;ZOOM&#34;)
            else:
                FPS = self.__prev_fps
                print(&#34;no longer zooming&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Sprite</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="karel_the_robot.Robot.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>documentation for self.id</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="karel_the_robot.Robot.add_method"><code class="name flex">
<span>def <span class="ident">add_method</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_method(self):
    def decorator(func):
        @wraps(func)
        def wrapper(self, *args, **kwargs):
            return func(self, *args, **kwargs)

        setattr(self, func.__name__, wrapper)
        # Note we are not binding func, but wrapper which accepts self but does exactly the same as func
        return func  # returning func means func can still be used normally

    return decorator</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, screen)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, screen):
    screen.blit(self.__image, (self.__rect.x, self.__rect.y))</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.front_is_clear"><code class="name flex">
<span>def <span class="ident">front_is_clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def front_is_clear(self):
    if self.__direction == 0:
        return not wall_at(self.__tile_x + 0.5, self.__tile_y)
    elif self.__direction == 180:
        return not wall_at(self.__tile_x - 0.5, self.__tile_y)
    elif self.__direction == 270:
        return not wall_at(self.__tile_x, self.__tile_y + 0.5)
    elif self.__direction == 90:
        return not wall_at(self.__tile_x, self.__tile_y - 0.5)
    else:
        return False</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.get_sleeve_color"><code class="name flex">
<span>def <span class="ident">get_sleeve_color</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sleeve_color(self):
    return self.__color[0]</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.has_any_beepers"><code class="name flex">
<span>def <span class="ident">has_any_beepers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_any_beepers(self):
    return self.__beepers &gt; 0</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self):

    if self.is_alive:
        self.wait()
        if self.front_is_clear():
            if self.__direction == 0:
                self.__rect.x += TILE_WIDTH
                self.__tile_x += 1
            elif self.__direction == 180:
                self.__rect.x -= TILE_WIDTH
                self.__tile_x -= 1
            elif self.__direction == 270:
                self.__rect.y += TILE_WIDTH
                self.__tile_y += 1
            elif self.__direction == 90:
                self.__rect.y -= TILE_WIDTH
                self.__tile_y -= 1
        else:
            continued_exception(&#34;[&#34; + self.__color[0] + &#34; Robot] I ran into a wall! &#34;)
            self.turn_off()

        print(&#34;tried to move&#34;)
        self.has_moved_this_frame = True</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.pick_beeper"><code class="name flex">
<span>def <span class="ident">pick_beeper</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pick_beeper(self):
    global BEEPERS

    if self.is_alive:
        self.wait()
        beepers_at_pos = [b for b in BEEPERS if b.__tile_x == self.__tile_x and b.__tile_y == self.__tile_y]
        if len(beepers_at_pos) &gt; 0:
            beepers_at_pos[0].dec()
            self.__beepers += 1
        self.has_moved_this_frame = True</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.put_beeper"><code class="name flex">
<span>def <span class="ident">put_beeper</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_beeper(self):
    global BEEPERS

    if self.is_alive:
        self.wait()
        if self.has_any_beepers():
            beepers_at_pos = [b for b in BEEPERS if b.tile_x == self.__tile_x and b.tile_y == self.__tile_y]
            self.__beepers -= 1
            if len(beepers_at_pos) &gt; 0:
                beepers_at_pos[0].inc()
            else:
                BEEPERS.add(Beeper(self.__tile_x, self.__tile_y, 1))
        else:
            # raise Exception(&#34;[&#34; + self.__color[0] + &#34; Robot] I don&#39;t have any beepers! &#34;)
            continued_exception(&#34;[&#34; + self.__color[0] + &#34; Robot] I don&#39;t have any beepers! &#34;)
            self.turn_off()

        print(&#34;tried to put beeper&#34; + str(self.__beepers))
        self.has_moved_this_frame = True</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.scale_image"><code class="name flex">
<span>def <span class="ident">scale_image</span></span>(<span>self, width)</span>
</code></dt>
<dd>
<div class="desc"><p>documentation for scale_image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_image(self, width):
    &#34;&#34;&#34;documentation for scale_image&#34;&#34;&#34;
    self.__image = pygame.transform.rotate(
        pygame.transform.scale(readable_pixarray_to_surface(self.__array), (width, width)),
        self.__direction)
    self.__rect = self.__image.get_rect()
    self.__rect.x = tile_to_point(self.__tile_x - 0.5)
    self.__rect.y = tile_to_point(self.__tile_y - 0.5)</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.set_zoom_fps"><code class="name flex">
<span>def <span class="ident">set_zoom_fps</span></span>(<span>self, fps)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_zoom_fps(self, fps):
    self.__zoom_fps = fps</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.turn_left"><code class="name flex">
<span>def <span class="ident">turn_left</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_left(self):
    if self.is_alive:
        self.wait()
        self.__image = pygame.transform.rotate(self.__image, 90)
        self.__direction = (self.__direction + 90) % 360
        self.has_moved_this_frame = True</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.turn_off"><code class="name flex">
<span>def <span class="ident">turn_off</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_off(self):
    global TILE_WIDTH

    if self.is_alive:
        self.wait()
        self.is_alive = False
        self.__array = replace_2d(self.__array, YELLOW, L_GREY)
        self.scale_image(TILE_WIDTH)
        print(&#34;am dead&#34;)</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self):
    global FPS
    if self.is_alive:  # prevents commands from being run before the loop checks for dead robots, putting it in an infinite loop
        while self.has_moved_this_frame:
            # print(&#34;waiting for frame&#34;)
            time.sleep(1.0 / FPS)</code></pre>
</details>
</dd>
<dt id="karel_the_robot.Robot.zoom"><code class="name flex">
<span>def <span class="ident">zoom</span></span>(<span>self, on)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zoom(self, on):  # TODO: zooming is quirky

    if self.is_alive:
        self.wait()
        global FPS
        self.has_moved_this_frame = True
        if on:
            self.__prev_fps = FPS
            FPS = self.__zoom_fps
            print(&#34;ZOOM&#34;)
        else:
            FPS = self.__prev_fps
            print(&#34;no longer zooming&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="karel_the_robot.World"><code class="flex name class">
<span>class <span class="ident">World</span></span>
<span>(</span><span>width, height, name='Karel J Robot', fps=4, beeper_pos=[], wall_pos=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class World(object):
    # maybe add window size attributes
    def __init__(self, width, height, name=&#34;Karel J Robot&#34;, fps=4, beeper_pos=[], wall_pos=[]):
        global FPS, BEEPERS
        self.IDEAL_HEIGHT = 700
        self.IDEAL_WIDTH = 900
        FPS = fps

        self.__width = width
        self.__height = height
        self.__beeper_pos = beeper_pos
        self.__wall_pos = wall_pos

        BEEPERS = pygame.sprite.Group()
        self.__robots = []
        self.__screen = None
        self.__background = None
        self.__running = False
        self.__clock = None
        self.__idle_frames = 0
        # self.interval = 10

        self.__thread = threading.Thread(target=self.__run, args=())
        self.__thread.daemon = False  # Daemonize thread
        self.__name = name

    @classmethod  # constructor for loading a file
    def from_file(cls, filename):
        file = open(filename)
        width = 0
        height = 0
        fps = 4
        name = &#34;Karel J Robot&#34;
        beepers = []
        walls = []

        for l in file:
            if l.startswith(&#34;legacy: &#34;):
                print(&#34;legacy mode&#34;)
            elif l.startswith(&#34;name: &#34;) and len(l) &gt; 6:
                name = str(l[6:])
            elif l.startswith(&#34;size: &#34;):
                for i in range(6, len(l)):
                    if l[i] == &#39;(&#39;:
                        p = extract_vals_inside_parenthesis(l, i)
                        if len(p) == 2:
                            width = int(p[0])
                            height = int(p[1])
            elif l.startswith(&#34;fps: &#34;) and len(l) &gt; 5:
                fps = int(l[5:])
            elif l.startswith(&#34;beepers: &#34;):
                for i in range(9, len(l)):
                    if l[i] == &#39;(&#39;:
                        p = extract_vals_inside_parenthesis(l, i)
                        if len(p) == 3:
                            beepers.append((int(p[0]), int(p[1]), int(p[2])))
            elif l.startswith(&#34;walls: &#34;):
                for i in range(7, len(l)):
                    if l[i] == &#39;(&#39;:
                        p = extract_vals_inside_parenthesis(l, i)
                        if len(p) == 4:
                            walls.append((0 if p[0] == &#39;h&#39; else 1, float(p[1]), float(p[2]), float(p[3])))
        file.close()
        return cls(width, height, name=name, fps=fps, beeper_pos=beepers, wall_pos=walls)

    def add_robots(self, *robots):
        if self.__thread.is_alive():
            continued_exception(&#34;[World] Cannot add robots while the world is running!&#34;)
        else:
            for r in robots:
                self.__robots.append(r)
                print(&#34;[World] Added &#34; + r.get_sleeve_color() + &#34; Robot&#34;)

    def save_screenshot(self, filename=&#34;screenshot.jpg&#34;):
        if not filename.endswith(&#34;.jpg&#34;):
            filename += &#34;.jpg&#34;
        if self.__thread.is_alive():
            pygame.image.save(self.__screen, filename)
            print(&#34;[World] Saved screenshot as \&#34;&#34; + filename + &#34;\&#34;.&#34;)
        else:
            continued_exception(&#34;[World] Cannot take screenshot until the world is running!&#34;)

    def set_fps(self, fps):
        global FPS
        FPS = fps
        print(&#34;[World] Changed FPS&#34;)

    def start(self):
        self.__thread.start()

    def __run(self):

        print(&#34;\n&#34; + &#34;[World] Initializing...&#34; + &#34;\n&#34;)
        global SCREEN_WIDTH, SCREEN_HEIGHT, TILE_WIDTH, FPS, BEEPERS, BEEPER_SURF, WALLS
        pygame.init()
        TILE_WIDTH = int(min(self.IDEAL_WIDTH / (self.__width + 1), self.IDEAL_HEIGHT / (self.__height + 1)))
        if TILE_WIDTH % 2 == 1:
            TILE_WIDTH -= 1
        SCREEN_WIDTH = TILE_WIDTH * (self.__width + 1)
        SCREEN_HEIGHT = TILE_WIDTH * (self.__height + 1)
        print(&#34;[World] Screen height is &#34; + str(SCREEN_HEIGHT))
        self.__screen = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])  # add scaling

        BEEPER_SURF = pygame.transform.scale(readable_pixarray_to_surface(numpy.array(BEEPER)),
                                             (TILE_WIDTH, TILE_WIDTH))

        print(&#34;[World] Scaling robots...&#34;)
        for r in self.__robots:
            r.scale_image(TILE_WIDTH)

        for p in self.__beeper_pos:
            BEEPERS.add(Beeper(p[0], p[1], p[2]))

        print(&#34;[World] Generating background...&#34;)
        self.__background = pygame.Surface([SCREEN_WIDTH, SCREEN_HEIGHT])
        self.__background.fill(WHITE)
        for x in range(0, self.__width + 1):
            pygame.draw.line(self.__background, BLACK, ((x + 0.5) * TILE_WIDTH, 0.5 * TILE_WIDTH),
                             ((x + 0.5) * TILE_WIDTH, (self.__height + 0.5) * TILE_WIDTH))
            self.__background.blit(pygame.font.Font(&#39;freesansbold.ttf&#39;, 10).render(str(x), True, BLACK),
                                   ((x + 0.5) * TILE_WIDTH, 0.25 * TILE_WIDTH))
        for y in range(0, self.__height + 1):
            pygame.draw.line(self.__background, BLACK, (0.5 * TILE_WIDTH, (y + 0.5) * TILE_WIDTH),
                             ((self.__width + 0.5) * TILE_WIDTH, (y + 0.5) * TILE_WIDTH))
            self.__background.blit(pygame.font.Font(&#39;freesansbold.ttf&#39;, 10).render(str(y), True, BLACK),
                                   (0.25 * TILE_WIDTH, (y + 0.5) * TILE_WIDTH))

        for w in self.__wall_pos:
            pygame.draw.line(self.__background, RED,
                             (tile_to_point(w[1]), tile_to_point(w[2])),
                             (tile_to_point(w[3] if w[0] == 0 else w[1]), tile_to_point(w[3] if w[0] == 1 else w[2])),
                             3)
            for i in range(0, int(abs(w[3] - w[1 if w[0] == 0 else 2]))):
                # works no matter what order the walls are in
                WALLS.append(
                    (w[1] + ((i + 0.5 if w[1] &lt;= w[3] else 0 - i - 0.5) if w[0] == 0 else 0),
                     w[2] + ((i + 0.5 if w[2] &lt;= w[3] else 0 - i - 0.5) if w[0] == 1 else 0))
                )
        pygame.display.set_caption(self.__name)

        self.__clock = pygame.time.Clock()
        self.__running = True
        self.__idle_frames = 0

        print(&#34;[World] Done!&#34; + &#34;\n\n\n\n&#34;)
        print(WALLS)
        # quits if it idles for more than one second
        while sum(r.is_alive for r in self.__robots) &gt; 0 and self.__idle_frames &lt; FPS:
            pygame.event.get()  # required or else the window thinks it&#39;s not responding
            self.__screen.blit(self.__background, (0, 0))
            BEEPERS.draw(self.__screen)

            any_robots_moved = False
            for r in self.__robots:
                any_robots_moved = any_robots_moved or r.has_moved_this_frame
                r.draw(self.__screen)
                r.has_moved_this_frame = False

            if any_robots_moved:
                self.__idle_frames = 0
            else:
                self.__idle_frames += 1

            self.__clock.tick(FPS)
            pygame.display.flip()
        print(&#34;[World] Saving screenshot...&#34;)
        pygame.image.save(self.__screen, &#34;final_world_status.jpg&#34;)
        print(&#34;[World] Quitting...&#34;)
        pygame.quit()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="karel_the_robot.World.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod  # constructor for loading a file
def from_file(cls, filename):
    file = open(filename)
    width = 0
    height = 0
    fps = 4
    name = &#34;Karel J Robot&#34;
    beepers = []
    walls = []

    for l in file:
        if l.startswith(&#34;legacy: &#34;):
            print(&#34;legacy mode&#34;)
        elif l.startswith(&#34;name: &#34;) and len(l) &gt; 6:
            name = str(l[6:])
        elif l.startswith(&#34;size: &#34;):
            for i in range(6, len(l)):
                if l[i] == &#39;(&#39;:
                    p = extract_vals_inside_parenthesis(l, i)
                    if len(p) == 2:
                        width = int(p[0])
                        height = int(p[1])
        elif l.startswith(&#34;fps: &#34;) and len(l) &gt; 5:
            fps = int(l[5:])
        elif l.startswith(&#34;beepers: &#34;):
            for i in range(9, len(l)):
                if l[i] == &#39;(&#39;:
                    p = extract_vals_inside_parenthesis(l, i)
                    if len(p) == 3:
                        beepers.append((int(p[0]), int(p[1]), int(p[2])))
        elif l.startswith(&#34;walls: &#34;):
            for i in range(7, len(l)):
                if l[i] == &#39;(&#39;:
                    p = extract_vals_inside_parenthesis(l, i)
                    if len(p) == 4:
                        walls.append((0 if p[0] == &#39;h&#39; else 1, float(p[1]), float(p[2]), float(p[3])))
    file.close()
    return cls(width, height, name=name, fps=fps, beeper_pos=beepers, wall_pos=walls)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="karel_the_robot.World.add_robots"><code class="name flex">
<span>def <span class="ident">add_robots</span></span>(<span>self, *robots)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_robots(self, *robots):
    if self.__thread.is_alive():
        continued_exception(&#34;[World] Cannot add robots while the world is running!&#34;)
    else:
        for r in robots:
            self.__robots.append(r)
            print(&#34;[World] Added &#34; + r.get_sleeve_color() + &#34; Robot&#34;)</code></pre>
</details>
</dd>
<dt id="karel_the_robot.World.save_screenshot"><code class="name flex">
<span>def <span class="ident">save_screenshot</span></span>(<span>self, filename='screenshot.jpg')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_screenshot(self, filename=&#34;screenshot.jpg&#34;):
    if not filename.endswith(&#34;.jpg&#34;):
        filename += &#34;.jpg&#34;
    if self.__thread.is_alive():
        pygame.image.save(self.__screen, filename)
        print(&#34;[World] Saved screenshot as \&#34;&#34; + filename + &#34;\&#34;.&#34;)
    else:
        continued_exception(&#34;[World] Cannot take screenshot until the world is running!&#34;)</code></pre>
</details>
</dd>
<dt id="karel_the_robot.World.set_fps"><code class="name flex">
<span>def <span class="ident">set_fps</span></span>(<span>self, fps)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fps(self, fps):
    global FPS
    FPS = fps
    print(&#34;[World] Changed FPS&#34;)</code></pre>
</details>
</dd>
<dt id="karel_the_robot.World.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    self.__thread.start()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="karel_the_robot.SLEEVE_COLORS" href="#karel_the_robot.SLEEVE_COLORS">SLEEVE_COLORS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="karel_the_robot.continued_exception" href="#karel_the_robot.continued_exception">continued_exception</a></code></li>
<li><code><a title="karel_the_robot.extract_vals_inside_parenthesis" href="#karel_the_robot.extract_vals_inside_parenthesis">extract_vals_inside_parenthesis</a></code></li>
<li><code><a title="karel_the_robot.point_to_tile" href="#karel_the_robot.point_to_tile">point_to_tile</a></code></li>
<li><code><a title="karel_the_robot.readable_pixarray_to_surface" href="#karel_the_robot.readable_pixarray_to_surface">readable_pixarray_to_surface</a></code></li>
<li><code><a title="karel_the_robot.replace_2d" href="#karel_the_robot.replace_2d">replace_2d</a></code></li>
<li><code><a title="karel_the_robot.tile_to_point" href="#karel_the_robot.tile_to_point">tile_to_point</a></code></li>
<li><code><a title="karel_the_robot.wall_at" href="#karel_the_robot.wall_at">wall_at</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="karel_the_robot.Beeper" href="#karel_the_robot.Beeper">Beeper</a></code></h4>
<ul class="">
<li><code><a title="karel_the_robot.Beeper.dec" href="#karel_the_robot.Beeper.dec">dec</a></code></li>
<li><code><a title="karel_the_robot.Beeper.draw" href="#karel_the_robot.Beeper.draw">draw</a></code></li>
<li><code><a title="karel_the_robot.Beeper.inc" href="#karel_the_robot.Beeper.inc">inc</a></code></li>
<li><code><a title="karel_the_robot.Beeper.update_image" href="#karel_the_robot.Beeper.update_image">update_image</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="karel_the_robot.Robot" href="#karel_the_robot.Robot">Robot</a></code></h4>
<ul class="two-column">
<li><code><a title="karel_the_robot.Robot.add_method" href="#karel_the_robot.Robot.add_method">add_method</a></code></li>
<li><code><a title="karel_the_robot.Robot.draw" href="#karel_the_robot.Robot.draw">draw</a></code></li>
<li><code><a title="karel_the_robot.Robot.front_is_clear" href="#karel_the_robot.Robot.front_is_clear">front_is_clear</a></code></li>
<li><code><a title="karel_the_robot.Robot.get_sleeve_color" href="#karel_the_robot.Robot.get_sleeve_color">get_sleeve_color</a></code></li>
<li><code><a title="karel_the_robot.Robot.has_any_beepers" href="#karel_the_robot.Robot.has_any_beepers">has_any_beepers</a></code></li>
<li><code><a title="karel_the_robot.Robot.id" href="#karel_the_robot.Robot.id">id</a></code></li>
<li><code><a title="karel_the_robot.Robot.move" href="#karel_the_robot.Robot.move">move</a></code></li>
<li><code><a title="karel_the_robot.Robot.pick_beeper" href="#karel_the_robot.Robot.pick_beeper">pick_beeper</a></code></li>
<li><code><a title="karel_the_robot.Robot.put_beeper" href="#karel_the_robot.Robot.put_beeper">put_beeper</a></code></li>
<li><code><a title="karel_the_robot.Robot.scale_image" href="#karel_the_robot.Robot.scale_image">scale_image</a></code></li>
<li><code><a title="karel_the_robot.Robot.set_zoom_fps" href="#karel_the_robot.Robot.set_zoom_fps">set_zoom_fps</a></code></li>
<li><code><a title="karel_the_robot.Robot.turn_left" href="#karel_the_robot.Robot.turn_left">turn_left</a></code></li>
<li><code><a title="karel_the_robot.Robot.turn_off" href="#karel_the_robot.Robot.turn_off">turn_off</a></code></li>
<li><code><a title="karel_the_robot.Robot.wait" href="#karel_the_robot.Robot.wait">wait</a></code></li>
<li><code><a title="karel_the_robot.Robot.zoom" href="#karel_the_robot.Robot.zoom">zoom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="karel_the_robot.World" href="#karel_the_robot.World">World</a></code></h4>
<ul class="">
<li><code><a title="karel_the_robot.World.add_robots" href="#karel_the_robot.World.add_robots">add_robots</a></code></li>
<li><code><a title="karel_the_robot.World.from_file" href="#karel_the_robot.World.from_file">from_file</a></code></li>
<li><code><a title="karel_the_robot.World.save_screenshot" href="#karel_the_robot.World.save_screenshot">save_screenshot</a></code></li>
<li><code><a title="karel_the_robot.World.set_fps" href="#karel_the_robot.World.set_fps">set_fps</a></code></li>
<li><code><a title="karel_the_robot.World.start" href="#karel_the_robot.World.start">start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>